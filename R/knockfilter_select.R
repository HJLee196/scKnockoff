
# Output:
# Indices of the selected variables

#' Select variables using the knockoff filter
#'
#' @param W_imp A numeric matrix where the first row contains \eqn{-\log(p)}
#'   values computed from the original data, and the remaining rows contain the
#'   corresponding values computed from knockoff copies generated by a
#'   multi-knockoff procedure.
#' @param m A positive integer specifying the number of knockoff copies. If
#'   \code{m = 0}, it is set to \code{nrow(W_imp) - 1}.
#' @param q A numeric scalar in (0, 1) specifying the target FDR level.
#'
#' @return An integer vector containing the indices of the selected variables.
#'   If no variables are selected, \code{NULL} is returned.
#'
#' @family select
#'
#' @details Selects variables with FDR control using the knockoff filter. For
#'   \code{m = 1}, the standard (single) knockoff filter is used. For
#'   \code{m >= 2}, this function assumes a valid multi-knockoff construction
#'   (i.e., knockoff copies are generated jointly and satisfy the required
#'   exchangeability properties).
#'
#' @references
#' Candes, E. J., Fan, Y., Janson, L., and Lv, J. (2018).
#' \emph{Panning for gold: Model-X knockoffs for high-dimensional controlled
#' variable selection}.
#' \emph{Journal of the Royal Statistical Society: Series B (Statistical Methodology)},
#' 80(3), 551--577.
#'
#' Roquero Gimenez, J., and Zou, J. (2019).
#' \emph{Improving the stability of the knockoff procedure: Multiple simultaneous
#' knockoffs and entropy maximization}.
#' In \emph{Proceedings of the 22nd International Conference on Artificial Intelligence
#' and Statistics}, pp. 2184--2192.
#'
#' @examples
#' # Read a dataset from the Seurat package
#' library(Seurat)
#' pbmc_raw <- read.table(
#'   file = system.file('extdata', 'pbmc_raw.txt', package = 'Seurat'),
#'   as.is = TRUE
#' )
#' pbmc_small <- Seurat::CreateSeuratObject(counts = pbmc_raw)
#'
#' # Prepare dataset
#' np_data <- t(as.matrix(pbmc_small[['RNA']]$counts))
#' np_data <- ifelse(np_data>0,log(np_data),0)
#' pbmc_small[['RNA']]$data = t(np_data)
#'
#' np_data_exp <- t(as.matrix(pbmc_small[['RNA']]$counts))
#' np_data_exp <- ifelse(np_data_exp>0,1,0)
#'
#' np_data_exp.count <- apply(np_data_exp,2,sum)
#'
#' # Trim down data
#' discard <- which(np_data_exp.count<20)
#'
#' np_data <- np_data[,-discard]
#' np_data_exp <- np_data_exp[,-discard]
#' np_data_exp.count <- np_data_exp.count[-discard]
#' pbmc_small <- subset(pbmc_small,features = colnames(np_data))
#'
#'
#' # Center target matrix, but only center the expressed parts.
#' np_data.avg <- (colSums(np_data, na.rm = TRUE))/(np_data_exp.count-1)
#' np_data_centered <- sweep(np_data,2,np_data.avg,FUN = "-")*(np_data_exp)
#'
#' # CDR as additional covariate
#' X <- matrix(apply(np_data_exp,1,sum),ncol=1)
#'
#' # Impute missing values
#' min(np_data_exp.count)
#' np_data_imp = sc_softImpute(np_data_centered,np_data_exp,X,PC=15)
#'
#' # Decomp Knockoff construction
#' decomp_knk = create_decomp_knock(np_data_imp$X_imp,
#'                                  np_data_imp$Xl,
#'                                  np_data_imp$Bl,
#'                                  np_data_imp$err,
#'                                  np_data_imp$PC)
#'
#' decomp_knk <- rescale_knockoff(decomp_knk,np_data_exp,np_data.avg)
#'
#'
#' # Generate synthetic signal
#' np_data.scale <- apply(np_data, 2, scale)
#'
#' n <- dim(np_data.scale)[1]
#' p <- dim(np_data.scale)[2]
#'
#' norm_coef <- rep(0, p)
#' tmp_coef <- rep(0,20)
#'
#' set.seed(4202)
#' sign_strength = 3
#' for(i in 1:20){
#'   new_coef <- 0
#'   # truncate the coefficients which are too small
#'   while(isTRUE((new_coef)^2 < (sign_strength^2)*2*log(p)/n)){
#'     new_coef <- rnorm(1,0,sign_strength*sqrt(2*log(p)/n))
#'   }
#'
#'   tmp_coef[i] <- new_coef
#' }
#'
#' sig_coef <- sample(1:p,20)
#' norm_coef[sig_coef] <- tmp_coef
#'
#' label_p <- 1/(1 + exp(- np_data.scale %*% norm_coef))
#'
#' # Create random labels
#' label_binom <- rbinom(n = length(label_p), size = 1, prob = label_p)
#' label_ad <- ifelse((label_binom>=0.5),"y1", "y2")
#'
#' pbmc_small <- Seurat::SetIdent(object = pbmc_small, value = label_ad)
#'
#'
#' W_imp = feature_importance(pbmc_small,decomp_knk,bonf=TRUE,
#'                            ident.1 = 'y1', ident.2 = 'y2',
#'                            test.use ="MAST")
#'
#' # Won't be able to select anything due to the small sample size
#' selected = knockfilter_select(W_imp)
#'
#' @export
knockfilter_select <- function(W_imp,m=0,q=0.1){
  if (!requireNamespace("knockoff", quietly = TRUE)) {
    stop("Package 'knockoff' must be installed.", call. = FALSE)
  }

  # W_imp
  if (!is.matrix(W_imp) && !is.data.frame(W_imp)) {
    stop("`W_imp` must be a numeric matrix or data.frame.", call. = FALSE)
  }
  W_imp <- as.matrix(W_imp)
  if (!is.numeric(W_imp)) {
    stop("`W_imp` must contain only numeric values.", call. = FALSE)
  }
  if (anyNA(W_imp)) {
    stop("`W_imp` must not contain NA values.", call. = FALSE)
  }
  if (nrow(W_imp) < 2 || ncol(W_imp) < 1) {
    stop("`W_imp` must have at least 2 rows and at least 1 column.", call. = FALSE)
  }

  # q
  if (!is.numeric(q) || length(q) != 1 || is.na(q) || q <= 0 || q >= 1) {
    stop("`q` must be a numeric scalar in (0, 1).", call. = FALSE)
  }

  # m (allow 0 -> infer later)
  if (!is.numeric(m) || length(m) != 1 || is.na(m) || m < 0 || m != as.integer(m)) {
    stop("`m` must be a non-negative integer.", call. = FALSE)
  }
  if (m == 0) {
    m <- nrow(W_imp) - 1
  }
  if (m < 1) {
    stop("`m` must be at least 1 (or set `m = 0` to infer it from `W_imp`).", call. = FALSE)
  }
  if (m + 1 > nrow(W_imp)) {
    stop("Not enough importance statistics: `m + 1` must be <= nrow(`W_imp`).", call. = FALSE)
  }
  # After inference/validation, keep only required rows
  W_imp <- W_imp[1:(m + 1), , drop = FALSE]

  if (m == 1) {
    selected <- single_select(W_imp,q)
  } else {
    selected <- multi_select(W_imp,m,q)
  }

  if (length(selected) == 0) {
    selected <- NULL
  }

  return(selected)
}

# ---- Internal helper (not exported) -----------------------------------------
#' Internal helper for knockfilter_select(): single knockoff case.
#' @noRd
# Variable selection when we have one copy of knockoffs
single_select <- function(W_imp,q=0.1){

  W_imp = W_imp[1,] - W_imp[2,]

  threshold <- knockoff::knockoff.threshold(W_imp,fdr=q)
  selected <- which(W_imp >= threshold)

  return(selected)
}

#' Internal helper for knockfilter_select(): multi-knockoff case.
#' @noRd
# Variable selection when we have multiple copies of knockoffs
multi_select <- function(W_imp,m,q=0.1){

  W_max_ind = apply(W_imp,2,which.max)
  W_max = sapply(1:length(W_max_ind), function(x) W_imp[W_max_ind[x],x])
  W_med = sapply(1:length(W_max_ind), function(x) stats::median(W_imp[-W_max_ind[x],x]))

  tau_stab <- (W_max - W_med)
  kap = (W_max_ind==1 & tau_stab>0)

  ts = sort(c(0, abs(tau_stab)))
  ratio = sapply(ts, function(t) (1/m + 1/m*sum((tau_stab >= t)*(1-kap)))/max(1,sum((tau_stab >= t)*(kap))))
  ok = which(ratio <= q)
  threshold <- ifelse(length(which(ts[ok]>0)) > 0, ts[ok][which(ts[ok]>0)[1]], Inf)

  selected <- which(tau_stab*kap >= threshold)

  return(selected)
}
