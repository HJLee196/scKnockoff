% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ebh_select.R
\name{ebh_select}
\alias{ebh_select}
\title{Select variables using the eBH procedure}
\usage{
ebh_select(W_imp, m = 0, q = 0.1, qkn = NULL)
}
\arguments{
\item{W_imp}{A numeric matrix where the first row contains \eqn{-\log(p)}
values computed from the original data, and the remaining rows contain the
corresponding values computed from knockoff copies.}

\item{m}{A positive integer specifying the number of knockoff copies. If
\code{m = 0}, it is set to \code{nrow(W_imp) - 1}.}

\item{q}{A numeric scalar in (0, 1) specifying the target FDR level.}

\item{qkn}{A numeric scalar in (0, \code{q}] specifying the FDR level used
to compute e-values. If \code{NULL}, defaults to \code{q/2}.}
}
\value{
An integer vector containing the indices of the selected variables.
If no variables are selected, \code{NULL} is returned.
}
\description{
Select variables using the eBH procedure
}
\details{
Select variables with FDR control using the eBH procedure. The
knockoffs used to compute e-values can be multiple single knockoffs, which
do not require joint exchangeability across knockoff copies.
}
\examples{
# Read a dataset from the Seurat package
library(Seurat)
pbmc_raw <- read.table(
  file = system.file('extdata', 'pbmc_raw.txt', package = 'Seurat'),
  as.is = TRUE
)
pbmc_small <- Seurat::CreateSeuratObject(counts = pbmc_raw)

# Prepare dataset
np_data <- t(as.matrix(pbmc_small[['RNA']]$counts))
np_data <- ifelse(np_data>0,log(np_data),0)
pbmc_small[['RNA']]$data = t(np_data)

np_data_exp <- t(as.matrix(pbmc_small[['RNA']]$counts))
np_data_exp <- ifelse(np_data_exp>0,1,0)

np_data_exp.count <- apply(np_data_exp,2,sum)

# Trim down data
discard <- which(np_data_exp.count<20)

np_data <- np_data[,-discard]
np_data_exp <- np_data_exp[,-discard]
np_data_exp.count <- np_data_exp.count[-discard]
pbmc_small <- subset(pbmc_small,features = colnames(np_data))


# Center target matrix, but only center the expressed parts.
np_data.avg <- (colSums(np_data, na.rm = TRUE))/(np_data_exp.count-1)
np_data_centered <- sweep(np_data,2,np_data.avg,FUN = "-")*(np_data_exp)

# CDR as additional covariate
X <- matrix(apply(np_data_exp,1,sum),ncol=1)

# Impute missing values
min(np_data_exp.count)
np_data_imp <- sc_softImpute(np_data_centered,np_data_exp, X, PC=5)


# Multi-decomp Knockoff construction
m <- 2
decomp_knk <- create_multi_decomp_knock(np_data_imp$X_imp,
                                        np_data_imp$Xl,
                                        np_data_imp$Bl,
                                        np_data_imp$err,
                                        np_data_imp$PC,
                                        m)
decomp_knk <- rescale_knockoff(decomp_knk, np_data_exp,np_data.avg)

# Generate synthetic signal
np_data.scale <- apply(np_data, 2, scale)

n <- dim(np_data.scale)[1]
p <- dim(np_data.scale)[2]

norm_coef <- rep(0, p)
tmp_coef <- rep(0,20)

set.seed(4202)
sign_strength <- 3
for(i in 1:20){
  new_coef <- 0
  # truncate the coefficients which are too small
  while(isTRUE((new_coef)^2 < (sign_strength^2)*2*log(p)/n)){
    new_coef <- rnorm(1,0,sign_strength*sqrt(2*log(p)/n))
  }

  tmp_coef[i] <- new_coef
}

sig_coef <- sample(1:p,20)
norm_coef[sig_coef] <- tmp_coef

label_p <- 1/(1 + exp(- np_data.scale \%*\% norm_coef))

# Create random labels
label_binom <- rbinom(n = length(label_p), size = 1, prob = label_p)
label_ad <- ifelse((label_binom>=0.5),"y1", "y2")

pbmc_small <- Seurat::SetIdent(object = pbmc_small, value = label_ad)


W_imp <- feature_importance(pbmc_small, decomp_knk, bonf=TRUE,
                            ident.1 = 'y1', ident.2 = 'y2',
                            test.use = "LR")

# Won't be able to select anything due to the small sample size
selected <- ebh_select(W_imp)

}
\references{
Ren, Z., and Foygel Barber, R. (2022).
\emph{Derandomized knockoffs: Leveraging e-values for false discovery rate control}.
arXiv preprint arXiv:2205.15461.
The implementation is adapted in part from the reference code
available at \url{https://github.com/zhimeir/derandomized_knockoffs_fdr},
with minor implementation-level modifications.
}
\seealso{
Other select: 
\code{\link{feature_importance}()},
\code{\link{knockfilter_select}()}
}
\concept{select}
