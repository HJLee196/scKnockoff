% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/feature_importance.R
\name{feature_importance}
\alias{feature_importance}
\title{Calculate feature importance based on p-values.}
\usage{
feature_importance(
  np_data.sub,
  np_data.knockoff,
  bonf = TRUE,
  test.use,
  latent.vars = NULL,
  ident.1 = NULL,
  slot_name = "data",
  ...
)
}
\arguments{
\item{np_data.sub}{A \code{Seurat} object containing the original data.}

\item{np_data.knockoff}{A numeric matrix representing a single knockoff copy,
or a list of such matrices for eBH or multiple knockoff procedures.
The knockoffs must be rescaled prior to calling this function.}

\item{bonf}{Logical scalar; if \code{TRUE}, use Bonferroni-adjusted p-values
to compute feature importance statistics. Default is \code{TRUE}.}

\item{test.use}{A character string specifying the test used to compute
feature importance statistics. This argument corresponds to
\code{test.use} in \code{Seurat::FindMarkers}. In addition, the lasso
coefficient difference statistic is supported by setting
\code{test.use = "LCD"}.}

\item{latent.vars}{A character vector specifying covariates to be included
when computing feature importance. These variables must be present in
the \code{Seurat} object.}

\item{ident.1}{Same as \code{ident.1} in \code{Seurat::FindMarkers}. If
\code{NULL}, the first level of \code{Idents(np_data.sub)} is used.}

\item{slot_name}{A character string specifying which assay slot (or layer) to use.
This argument is passed to \code{Seurat::FindMarkers} as \code{slot}.}

\item{...}{Additional arguments passed to \code{Seurat::FindMarkers}.}
}
\value{
A numeric matrix of dimension \eqn{(m+1) \times p} when \code{np_data.knockoff}
is a list of \code{m} knockoff copies, or \eqn{2 \times p} when a single
knockoff matrix is provided. The first row corresponds to the original data.
}
\description{
Calculate feature importance based on p-values.
}
\details{
Uses \code{Seurat::FindMarkers} to compute p-value-based feature
importance statistics. The \code{"MAST"} option requires the \pkg{MAST}
package (\url{https://github.com/RGLab/MAST}).
}
\examples{
# Read a dataset from the Seurat package
library(Seurat)
pbmc_raw <- read.table(
  file = system.file('extdata', 'pbmc_raw.txt', package = 'Seurat'),
  as.is = TRUE
)
pbmc_small <- Seurat::CreateSeuratObject(counts = pbmc_raw)

# Prepare dataset
np_data <- t(as.matrix(pbmc_small[['RNA']]$counts))
np_data <- ifelse(np_data>0,log(np_data),0)
pbmc_small[['RNA']]$data = t(np_data)

np_data_exp <- t(as.matrix(pbmc_small[['RNA']]$counts))
np_data_exp <- ifelse(np_data_exp>0,1,0)

np_data_exp.count <- apply(np_data_exp,2,sum)

# Trim down data
discard <- which(np_data_exp.count<20)

np_data <- np_data[,-discard]
np_data_exp <- np_data_exp[,-discard]
np_data_exp.count <- np_data_exp.count[-discard]
pbmc_small <- subset(pbmc_small,features = colnames(np_data))


# Center target matrix, but only center the expressed parts.
np_data.avg <- (colSums(np_data, na.rm = TRUE))/(np_data_exp.count-1)
np_data_centered <- sweep(np_data,2,np_data.avg,FUN = "-")*(np_data_exp)

# CDR as additional covariate
X <- matrix(apply(np_data_exp,1,sum),ncol=1)

# Impute missing values
min(np_data_exp.count)
np_data_imp <- sc_softImpute(np_data_centered,np_data_exp,X,PC=15)

# Decomp Knockoff construction
set.seed(1010)
decomp_knock <- create_decomp_knock(np_data_imp$X_imp,
                                    np_data_imp$Xl,
                                    np_data_imp$Bl,
                                    np_data_imp$err,
                                    np_data_imp$PC)

decomp_knock <- rescale_knockoff(decomp_knock,np_data_exp,np_data.avg)


# Generate synthetic signal
np_data.scale <- apply(np_data, 2, scale)

n <- dim(np_data.scale)[1]
p <- dim(np_data.scale)[2]

norm_coef <- rep(0, p)
tmp_coef <- rep(0,20)

sign_strength <- 3
for(i in 1:20){
  new_coef <- 0
  # truncate the coefficients which are too small
  while(isTRUE((new_coef)^2 < (sign_strength^2)*2*log(p)/n)){
    new_coef <- rnorm(1,0,sign_strength*sqrt(2*log(p)/n))
  }

  tmp_coef[i] <- new_coef
}

sig_coef <- sample(1:p,20)
norm_coef[sig_coef] <- tmp_coef

label_p <- 1/(1 + exp(- np_data.scale \%*\% norm_coef))

# Create random labels
label_binom <- rbinom(n = length(label_p), size = 1, prob = label_p)
label_ad <- ifelse((label_binom>=0.5),"y1", "y2")

pbmc_small <- Seurat::SetIdent(object = pbmc_small, value = label_ad)


W_imp <- feature_importance(pbmc_small, decomp_knock, bonf=TRUE,
                           ident.1 = 'y1', ident.2 = 'y2',
                           test.use ="MAST")

# Won't be able to select anything due to the small sample size
selected <- knockfilter_select(W_imp)

}
\seealso{
Other select: 
\code{\link{ebh_select}()},
\code{\link{knockfilter_select}()}
}
\concept{select}
