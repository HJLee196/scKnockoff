% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/create_decomp_knock.R
\name{create_decomp_knock}
\alias{create_decomp_knock}
\title{Knockoff construction using matrix decomposition}
\usage{
create_decomp_knock(np_data.matrix.imp, Xl, Bl, err, PC, decomp = TRUE)
}
\arguments{
\item{np_data.matrix.imp}{A numeric matrix of dimension n x p containing the
imputed data.}

\item{Xl}{A numeric matrix of dimension n x k containing latent factors, where
k = PC plus the number of additional covariates.}

\item{Bl}{A numeric matrix of dimension k x p containing factor loadings.}

\item{err}{A numeric vector of length p containing estimated error variances.}

\item{PC}{A positive integer specifying the number of latent factors,
excluding additional covariates.}

\item{decomp}{Logical scalar; if \code{TRUE}, generate knockoffs without solving an approximate
semidefinite program (ASDP). If \code{FALSE}, generate knockoffs with ASDP.}
}
\value{
If successful, a numeric matrix of dimension \eqn{n \times p} containing
one set of knockoff variables constructed using either a matrix
decomposition-based covariance estimate or an ASDP-based approach (see
Details). The returned matrix is not rescaled; rescaling should be
performed separately (e.g., using \code{rescale_knockoff}). If knockoff
construction fails, the function returns \code{NULL} and issues a
warning.
}
\description{
Knockoff construction using matrix decomposition
}
\details{
Constructs knockoff variables using second-order Gaussian knockoff
generation. When \code{decomp = TRUE}, the method uses a matrix
decomposition-based covariance estimator to reduce computational and
memory costs in high-dimensional settings compared to full
covariance-based approaches. When \code{decomp = FALSE}, the method constructs knockoffs using an
approximate semidefinite programming (ASDP) approach.
}
\examples{
set.seed(2024)
# Create dataset
Xl <- matrix(rnorm(1000),nrow = 100)
Bl <- matrix(rnorm(800),ncol=80)
err <- abs(rnorm(80,sd=3))

E <- matrix(NA,nrow = 100,ncol = 80)
for(i in 1:80){
  E[,i] <- rnorm(100, sd = err[i])
}

np_data <- Xl\%*\%Bl + E

rownames(np_data) <- paste0("r", 1:100)
colnames(np_data) <- paste0("c", 1:80)

# Create missing data
miss <- sample(1:prod(dim(np_data)),floor(prod(dim(np_data))*0.6))
np_data[miss] <- 0

np_data_exp <- matrix(1,nrow=100,ncol=80)
np_data_exp[miss] <- 0

np_data_exp.count <- apply(np_data_exp,2,sum)

# Center target matrix, but only center the expressed parts.
np_data.avg <- (colSums(np_data, na.rm = TRUE))/(np_data_exp.count-1)
np_data_centered <- sweep(np_data,2,np_data.avg,FUN = "-")*(np_data_exp)

# Impute missing values
np_data_imp <- sc_softImpute(np_data_centered,np_data_exp,Xl[,1:3],PC=min(np_data_exp.count)-5)

# Decomp Knockoff construction
decomp_knock <- create_decomp_knock(np_data_imp$X_imp,
                                    np_data_imp$Xl,
                                    np_data_imp$Bl,
                                    np_data_imp$err,
                                    np_data_imp$PC)

decomp_knock <- rescale_knockoff(decomp_knock, np_data_exp, np_data.avg)

}
\seealso{
Other create: 
\code{\link{create_lr_knock}()},
\code{\link{create_multi_decomp_knock}()},
\code{\link{create_multi_lr_knock}()}
}
\concept{create}
