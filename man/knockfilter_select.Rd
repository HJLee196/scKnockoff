% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/knockfilter_select.R
\name{knockfilter_select}
\alias{knockfilter_select}
\title{Select variables using the knockoff filter}
\usage{
knockfilter_select(W_imp, m = 0, q = 0.1)
}
\arguments{
\item{W_imp}{A numeric matrix where the first row contains \eqn{-\log(p)}
values computed from the original data, and the remaining rows contain the
corresponding values computed from knockoff copies generated by a
multi-knockoff procedure.}

\item{m}{A positive integer specifying the number of knockoff copies. If
\code{m = 0}, it is set to \code{nrow(W_imp) - 1}.}

\item{q}{A numeric scalar in (0, 1) specifying the target FDR level.}
}
\value{
An integer vector containing the indices of the selected variables.
If no variables are selected, \code{NULL} is returned.
}
\description{
Select variables using the knockoff filter
}
\details{
Selects variables with FDR control using the knockoff filter. For
\code{m = 1}, the standard (single) knockoff filter is used. For
\code{m >= 2}, this function assumes a valid multi-knockoff construction
(i.e., knockoff copies are generated jointly and satisfy the required
exchangeability properties).
}
\examples{
# Read a dataset from the Seurat package
library(Seurat)
pbmc_raw <- read.table(
  file = system.file('extdata', 'pbmc_raw.txt', package = 'Seurat'),
  as.is = TRUE
)
pbmc_small <- Seurat::CreateSeuratObject(counts = pbmc_raw)

# Prepare dataset
np_data <- t(as.matrix(pbmc_small[['RNA']]$counts))
np_data <- ifelse(np_data>0,log(np_data),0)
pbmc_small[['RNA']]$data = t(np_data)

np_data_exp <- t(as.matrix(pbmc_small[['RNA']]$counts))
np_data_exp <- ifelse(np_data_exp>0,1,0)

np_data_exp.count <- apply(np_data_exp,2,sum)

# Trim down data
discard <- which(np_data_exp.count<20)

np_data <- np_data[,-discard]
np_data_exp <- np_data_exp[,-discard]
np_data_exp.count <- np_data_exp.count[-discard]
pbmc_small <- subset(pbmc_small,features = colnames(np_data))


# Center target matrix, but only center the expressed parts.
np_data.avg <- (colSums(np_data, na.rm = TRUE))/(np_data_exp.count-1)
np_data_centered <- sweep(np_data,2,np_data.avg,FUN = "-")*(np_data_exp)

# CDR as additional covariate
X <- matrix(apply(np_data_exp,1,sum),ncol=1)

# Impute missing values
min(np_data_exp.count)
np_data_imp = sc_softImpute(np_data_centered,np_data_exp,X,PC=15)

# Decomp Knockoff construction
decomp_knk = create_decomp_knock(np_data_imp$X_imp,
                                 np_data_imp$Xl,
                                 np_data_imp$Bl,
                                 np_data_imp$err,
                                 np_data_imp$PC)

decomp_knk <- rescale_knockoff(decomp_knk,np_data_exp,np_data.avg)


# Generate synthetic signal
np_data.scale <- apply(np_data, 2, scale)

n <- dim(np_data.scale)[1]
p <- dim(np_data.scale)[2]

norm_coef <- rep(0, p)
tmp_coef <- rep(0,20)

set.seed(4202)
sign_strength = 3
for(i in 1:20){
  new_coef <- 0
  # truncate the coefficients which are too small
  while(isTRUE((new_coef)^2 < (sign_strength^2)*2*log(p)/n)){
    new_coef <- rnorm(1,0,sign_strength*sqrt(2*log(p)/n))
  }

  tmp_coef[i] <- new_coef
}

sig_coef <- sample(1:p,20)
norm_coef[sig_coef] <- tmp_coef

label_p <- 1/(1 + exp(- np_data.scale \%*\% norm_coef))

# Create random labels
label_binom <- rbinom(n = length(label_p), size = 1, prob = label_p)
label_ad <- ifelse((label_binom>=0.5),"y1", "y2")

pbmc_small <- Seurat::SetIdent(object = pbmc_small, value = label_ad)


W_imp = feature_importance(pbmc_small,decomp_knk,bonf=TRUE,
                           ident.1 = 'y1', ident.2 = 'y2',
                           test.use ="MAST")

# Won't be able to select anything due to the small sample size
selected = knockfilter_select(W_imp)

}
\references{
Candes, E. J., Fan, Y., Janson, L., and Lv, J. (2018).
\emph{Panning for gold: Model-X knockoffs for high-dimensional controlled
variable selection}.
\emph{Journal of the Royal Statistical Society: Series B (Statistical Methodology)},
80(3), 551--577.

Roquero Gimenez, J., and Zou, J. (2019).
\emph{Improving the stability of the knockoff procedure: Multiple simultaneous
knockoffs and entropy maximization}.
In \emph{Proceedings of the 22nd International Conference on Artificial Intelligence
and Statistics}, pp. 2184--2192.
}
\seealso{
Other select: 
\code{\link{ebh_select}()},
\code{\link{feature_importance}()}
}
\concept{select}
