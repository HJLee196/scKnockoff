% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sc_softImpute.R
\name{sc_softImpute}
\alias{sc_softImpute}
\title{softImpute with additional covariates}
\usage{
sc_softImpute(
  np_data.matrix,
  np_data.matrix.exp,
  X = NULL,
  PC,
  lambda = NULL,
  lam_ratio = 0.2,
  max_it = 100
)
}
\arguments{
\item{np_data.matrix}{A centered numeric matrix of dimension n x p containing
the original variables.}

\item{np_data.matrix.exp}{A numeric matrix of dimension n x p indicating
observed entries, with 1 for observed values and 0 for missing values.}

\item{X}{A numeric matrix of additional covariates. If \code{NULL}, the
function reduces to a standard \code{softImpute}-based imputation.}

\item{PC}{A positive integer specifying the number of latent factors.}

\item{lambda}{A penalty parameter used for imputation; by default,
\code{softImpute::lambda0()} is used.}

\item{lam_ratio}{A ratio applied to \code{lambda0}; only used when
\code{lambda = NULL} and is set to 0.2 by default.}

\item{max_it}{A positive integer specifying the maximum number of iterations;
default is 100.}
}
\value{
A list containing the imputed data and estimated model components obtained
from the adjusted softImpute algorithm with additional covariates.
The returned list contains:
\describe{
\item{X_imp}{A numeric matrix of dimension n x p containing the imputed data
with error added.}
\item{Xl}{A numeric matrix of dimension n x k containing estimated latent
factors, where \code{k = ncol(X) + PC}.}
\item{Bl}{A numeric matrix of dimension k x p containing estimated factor
loadings, where \code{k = ncol(X) + PC}.}
\item{err}{A numeric vector of length p containing estimated error variances.}
\item{PC}{The number of latent factors used in the algorithm.}
}
}
\description{
softImpute with additional covariates
}
\details{
This function implements an adjusted softImpute algorithm that allows the
inclusion of additional covariates. Each variable must have more than
\code{ncol(X) + PC + 1} non-missing observations.
\code{ncol(X)} is treated as 0 when \code{X} is \code{NULL}.
}
\examples{
set.seed(2024)
# Create dataset
X <- matrix(rnorm(1000),nrow = 100)
Bl <- matrix(rnorm(800),ncol=80)
err <- abs(rnorm(80,sd=3))

E <- matrix(NA,nrow = 100,ncol = 80)
for(i in 1:80){
  E[,i] = rnorm(100, sd = err[i])
}

np_data <- X\%*\%Bl + E

rownames(np_data) <- paste0("r", 1:100)
colnames(np_data) <- paste0("c", 1:80)

# Create missing data
miss <- sample(1:prod(dim(np_data)),floor(prod(dim(np_data))*0.6))
np_data[miss] <- 0

np_data_exp <- matrix(1,nrow=100,ncol=80)
np_data_exp[miss] <- 0

np_data_exp.count <- apply(np_data_exp,2,sum)

# Center target matrix, but only center the expressed parts.
np_data.avg <- (colSums(np_data, na.rm = TRUE))/(np_data_exp.count-1)
np_data_centered <- sweep(np_data,2,np_data.avg,FUN = "-")*(np_data_exp)

# Impute missing values
np_data_imp <- sc_softImpute(np_data_centered,np_data_exp,X[,1:3],PC=min(np_data_exp.count)-5)

}
